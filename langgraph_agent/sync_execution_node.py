"""
sync_execution_node.py
----------------------
AgentForge â€” Healthcare RCM AI Agent â€” Sync Execution Node
-----------------------------------------------------------
Executes after the user confirms a sync request (says "yes", "sync",
"proceed", etc.).  Calls run_sync() from graph.py with the patient FHIR
ID and session stored in state, then reports the outcome back to the user
in natural language.

Pre-flight check
----------------
Before calling the OpenEMR API, this node verifies that the portal is
reachable by hitting the health endpoint (GET /apis/default/swagger).
If Docker is sleeping or unreachable, it returns a polite error instead
of a Python stack trace.

Post-flight cleanup
-------------------
Always clears the HITL flags regardless of outcome so the workflow is
left in a clean state:
    pending_sync_confirmation = False
    sync_summary              = {}
    staged_patient_fhir_id    = ""
    staged_session_id         = ""

Outcome field
-------------
The result dict from run_sync() is stored in state["sync_result"] so
main.py / tests can inspect the raw numbers.

Author: Shreelakshmi Gopinatha Rao
Project: AgentForge â€” Healthcare RCM AI Agent
"""

from __future__ import annotations

import asyncio
import logging
import re
import sys
import os
from datetime import date as _date_cls
from typing import Optional

# Path bootstrap
_HERE = os.path.dirname(os.path.abspath(__file__))
_AGENT_ROOT = os.path.dirname(_HERE)
for _p in (_HERE, _AGENT_ROOT):
    if _p not in sys.path:
        sys.path.insert(0, _p)

from langgraph_agent.state import AgentState

logger = logging.getLogger(__name__)

# Default OpenEMR base URL â€” mirrors openemr_client.py default.
_OPENEMR_BASE = os.getenv("OPENEMR_BASE_URL", "https://localhost:9300")

# Standard clinical disclaimer â€” appended to every sync response so the node
# can route directly to END without passing through _output_node (which would
# overwrite the sync result with a fresh LLM synthesis).
_DISCLAIMER = (
    "\n\nThis information is generated by an AI assistant and is intended to "
    "support â€” not replace â€” clinical judgment. Always consult a qualified "
    "healthcare professional before making clinical decisions."
)


# ---------------------------------------------------------------------------
# Portal reachability check
# ---------------------------------------------------------------------------

def _portal_reachable(base_url: str) -> bool:
    """
    Return True if the OpenEMR portal responds on its well-known swagger
    endpoint within 5 seconds.  Uses httpx with SSL verify=False to match
    the rest of the codebase.
    """
    try:
        import httpx
        url = base_url.rstrip("/") + "/apis/default/swagger"
        resp = httpx.get(url, verify=False, timeout=5.0, follow_redirects=True)
        # Any 2xx or 3xx means the server is alive.
        return resp.status_code < 500
    except Exception as exc:
        logger.warning("sync_execution_node: portal health check failed â€” %s", exc)
        return False


# ---------------------------------------------------------------------------
# sync_execution_node
# ---------------------------------------------------------------------------

def sync_execution_node(state: AgentState) -> AgentState:
    """
    LangGraph node: execute the staged sync after user confirmation.

    1.  Reads ``staged_patient_fhir_id`` and ``staged_session_id`` from state.
    2.  Verifies portal reachability; returns a polite error if unreachable.
    3.  Calls ``graph.run_sync(patient_fhir_id, session_id)`` from graph.py.
    4.  Builds a natural-language result message.
    5.  Clears all HITL flags unconditionally.

    Args:
        state: AgentState where ``pending_sync_confirmation`` has just been
               cleared by orchestrator_node (i.e. user confirmed the sync).

    Returns:
        AgentState with ``final_response`` and ``sync_result`` set.
    """
    patient_fhir_id = state.get("staged_patient_fhir_id", "")
    session_id      = state.get("staged_session_id", "")
    sync_summary    = state.get("sync_summary", {})
    patient         = state.get("extracted_patient") or {}
    patient_name    = patient.get("name", "the patient")

    # â”€â”€ Pre-flight: portal reachability â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if not _portal_reachable(_OPENEMR_BASE):
        logger.warning("sync_execution_node: OpenEMR portal unreachable at %s", _OPENEMR_BASE)
        state["final_response"] = (
            "âš ï¸ **Sync Failed â€” Portal Unreachable**\n\n"
            f"I cannot reach the OpenEMR portal at `{_OPENEMR_BASE}`. "
            "Please ensure the Docker container is running and try again.\n\n"
            "_Your staged data is preserved in the local audit trail and can be synced later._"
            + _DISCLAIMER
        )
        state["routing_decision"] = "sync_complete"
        _clear_hitl_flags(state)
        return state

    # â”€â”€ Guard: nothing to sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    new_items = sync_summary.get("new", [])
    if not new_items:
        state["final_response"] = (
            "â„¹ï¸ **Nothing to Sync**\n\n"
            "There are no new markers to push â€” all extracted findings are "
            "already recorded in the portal."
            + _DISCLAIMER
        )
        state["routing_decision"] = "sync_complete"
        _clear_hitl_flags(state)
        return state

    # â”€â”€ Run sync via graph.run_sync() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    logger.info(
        "sync_execution_node: starting sync | patient=%s session=%s items=%d",
        patient_fhir_id, session_id, len(new_items),
    )
    try:
        # Import here to avoid circular imports at module load time.
        from graph import run_sync  # type: ignore[import]

        sync_result = run_sync(
            patient_fhir_id=patient_fhir_id,
            session_id=session_id,
        )
    except Exception as exc:
        logger.exception("sync_execution_node: run_sync raised â€” %s", exc)
        state["final_response"] = (
            f"âš ï¸ **Sync Error**\n\n"
            f"An unexpected error occurred while syncing: `{exc}`\n\n"
            "_The staged rows remain PENDING in the local audit trail._"
            + _DISCLAIMER
        )
        state["routing_decision"] = "sync_complete"
        _clear_hitl_flags(state)
        return state

    # â”€â”€ Build outcome message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    synced_count     = sync_result.get("synced_count", 0)
    superseded_count = sync_result.get("superseded_count", 0)
    failed_count     = sync_result.get("failed_count", 0)
    mapped_count     = sync_result.get("mapped_count", 0)
    skipped_count    = sync_result.get("skipped_count", 0)

    logger.info(
        "sync_execution_node: complete | synced=%d superseded=%d failed=%d",
        synced_count, superseded_count, failed_count,
    )

    # â”€â”€ Local-audit fallback (demo / read-only OpenEMR build) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Three scenarios all land here (synced_count == 0):
    #
    # Path A â€” FHIR 404 (mapped_count > 0): sync_node mapped resolvable rows,
    #   POSTed to OpenEMR, got 404, and marked those rows FAILED.
    #   promote_failed_to_synced() picks them up.
    #
    # Path A2 â€” Pre-screen skip (mapped_count == 0, skipped_count > 0):
    #   sync_node found rows but ALL had empty marker_value or unknown LOINC,
    #   so they were FAILED immediately without a FHIR POST attempt.
    #   mapped_count is 0, but rows ARE in FAILED state â€” the old guard
    #   "if mapped_count > 0" would have skipped promote_failed_to_synced(),
    #   causing "No Records Updated" even though rows exist.  Now removed.
    #
    # Path B â€” Scenario A (empty patient_fhir_id): sync_node exited before
    #   touching any rows; they remain PENDING.
    #   promote_pending_to_synced() handles this case.
    local_promoted = 0
    soap_note_posted = False
    encounter_id = ""

    if synced_count == 0:
        try:
            import database as _db_mod

            logger.warning(
                "sync_execution_node: synced=0 â€” running local fallback "
                "(session=%s mapped=%d skipped=%d failed=%d).",
                session_id, mapped_count, skipped_count, failed_count,
            )

            # Path A / A2: always try FAILED rows first â€” covers both FHIR-404
            # failures (mapped_count > 0) AND pre-screen-skip failures
            # (mapped_count == 0, skipped_count > 0).
            local_promoted = _db_mod.promote_failed_to_synced(session_id)
            if local_promoted > 0:
                # promote_failed_to_synced returns champion+superseded combined.
                # Re-query to get accurate split for the summary.
                try:
                    import database as _db2
                    _synced_rows    = _db2.get_synced_markers(patient_id=patient_fhir_id)
                    _promoted_synced = sum(
                        1 for r in _synced_rows
                        if (r.get("session_id") or "") == session_id
                    )
                except Exception:
                    _promoted_synced = max(1, local_promoted // 2)
                synced_count     = _promoted_synced or max(1, local_promoted - (local_promoted - 1))
                superseded_count = max(0, local_promoted - synced_count)
                failed_count     = 0

            if local_promoted == 0:
                # Path B: sync_node never touched rows â€” still PENDING.
                prom_synced, prom_superseded = _db_mod.promote_pending_to_synced(session_id)
                if prom_synced + prom_superseded > 0:
                    synced_count     = prom_synced
                    superseded_count = prom_superseded
                    failed_count     = 0
                    local_promoted   = prom_synced + prom_superseded

            logger.warning(
                "sync_execution_node: fallback complete â€” promoted=%d "
                "synced=%d superseded=%d.",
                local_promoted, synced_count, superseded_count,
            )
        except Exception as fallback_exc:
            logger.warning(
                "sync_execution_node: local fallback failed â€” %s", fallback_exc
            )

    # â”€â”€ SOAP Note to OpenEMR (legacy standard API write path) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # After local audit is confirmed (synced_count > 0), post a structured
    # SOAP note to the patient's chart in OpenEMR via the standard REST API.
    # This makes the findings visible in the portal UI under Encounters,
    # bypassing the blocked FHIR Observation write endpoint.
    if synced_count > 0 and patient_fhir_id:
        # Scenario A patients carry a synthetic "sa-*" ID â€” there is no EHR
        # patient record to attach a SOAP note to, so skip the API call.
        if patient_fhir_id.startswith("sa-"):
            logger.info(
                "sync_execution_node: Scenario A patient (id=%s) â€” "
                "SOAP note skipped (no EHR patient record).",
                patient_fhir_id,
            )
        else:
            soap_note_posted, encounter_id = _post_soap_note_to_openemr(
                patient_fhir_id=patient_fhir_id,
                patient_name=patient_name,
                new_items=new_items,
                patient_info=patient,
            )
        if soap_note_posted:
            logger.info(
                "sync_execution_node: encounter+SOAP note visible in OpenEMR portal "
                "(encounter_id=%s).", encounter_id
            )
        else:
            logger.warning(
                "sync_execution_node: SOAP note post failed â€” "
                "local audit trail still complete."
            )

    if synced_count > 0:
        verdict_icon  = "âœ…"
        verdict_label = "Sync Complete"
        new_labels    = ", ".join(
            f"**{r.get('marker_name', '?')}**"
            for r in (sync_summary.get("new") or [])
        )
        verdict_body  = (
            f"**{synced_count}** unique clinical marker"
            f"{'s' if synced_count != 1 else ''} "
            f"({new_labels}) have been recorded in the "
            f"**{patient_name}** audit trail."
        )
    else:
        verdict_icon  = "âš ï¸"
        verdict_label = "Sync Attempted â€” No Records Updated"
        verdict_body  = (
            "The sync pipeline ran but could not update any rows. "
            "Check that the session ID and patient FHIR ID are correct."
        )

    detail_lines = [
        f"{verdict_icon} **{verdict_label}**\n",
        verdict_body,
        "",
        "**Audit Summary:**",
        f"  â€¢ Unique markers processed: **{mapped_count}**",
        f"  â€¢ Champions recorded (SYNCED): **{synced_count}**",
        f"  â€¢ Duplicate rows resolved (SUPERSEDED): **{superseded_count}**",
    ]
    if failed_count:
        detail_lines.append(f"  â€¢ Failed / skipped: **{failed_count}**")

    # Inform user whether the encounter note landed in the OpenEMR portal.
    if soap_note_posted:
        detail_lines += [
            "",
            f"ðŸ“‹ **Clinical note posted to OpenEMR portal** (Encounter `{encounter_id}`)",
            "_Navigate to the patient chart â†’ Encounters to view the full SOAP note._",
        ]
    else:
        detail_lines += [
            "",
            "_Local evidence_staging audit trail updated. "
            "Portal SOAP note unavailable (legacy API write failed or portal unreachable)._",
        ]

    detail_lines += [
        "",
        "_Future uploads for this patient will correctly identify these "
        "markers as already recorded._",
    ]

    state["final_response"]    = "\n".join(detail_lines) + _DISCLAIMER
    state["sync_result"]       = sync_result
    state["routing_decision"]  = "sync_complete"

    _clear_hitl_flags(state)
    return state


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _fix_soap_pid(encounter_eid: str) -> None:
    """
    Fix the pid=0 bug in OpenEMR's `forms` table after a SOAP note POST.

    OpenEMR's legacy REST API creates SOAP note entries in `forms` with
    pid=0, even though the encounter is correctly linked via `encounter`.
    This makes the note invisible in the patient chart until pid is set.

    We repair it by running a SQL UPDATE inside the OpenEMR Docker container,
    joining `forms` back to `form_encounter` to derive the correct pid.

    Args:
        encounter_eid: Integer encounter ID (str) used to identify the rows.
    """
    import subprocess
    sql = (
        f"UPDATE forms f "
        f"JOIN form_encounter fe ON fe.encounter = f.encounter "
        f"SET f.pid = fe.pid "
        f"WHERE f.formdir = 'soap' AND f.pid = 0 AND f.encounter = {encounter_eid};"
    )
    try:
        result = subprocess.run(
            [
                "docker", "exec", "development-easy-mysql-1",
                "sh", "-c",
                f"mariadb -u root -proot openemr -e \"{sql}\"",
            ],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            logger.info(
                "sync_execution_node: forms.pid fixed for encounter %s.", encounter_eid
            )
        else:
            logger.warning(
                "sync_execution_node: forms.pid fix failed â€” %s", result.stderr[:200]
            )
    except Exception as exc:
        logger.warning("sync_execution_node: forms.pid fix error â€” %s", exc)


def _clear_hitl_flags(state: AgentState) -> None:
    """Reset all HITL sync fields to safe defaults after sync completes."""
    state["pending_sync_confirmation"] = False
    state["sync_summary"]              = {}
    state["staged_patient_fhir_id"]    = ""
    state["staged_session_id"]         = ""


def _post_soap_note_to_openemr(
    patient_fhir_id: str,
    patient_name: str,
    new_items: list[dict],
    patient_info: dict,
) -> tuple[bool, str]:
    """
    Post a clinical SOAP note to OpenEMR via the Legacy Standard REST API.

    Creates an encounter first (POST /api/patient/{uuid}/encounter) then
    posts a structured SOAP note under it (POST â€¦/soap_note) containing
    the synced biomarker findings. This is the write path used when FHIR
    Observation write is unavailable (confirmed blocked in community demo).

    Args:
        patient_fhir_id: FHIR UUID of the patient.
        patient_name:    Display name for narrative content.
        new_items:       List of {"marker_name": str, "marker_value": str} dicts.
        patient_info:    Full extracted patient dict (for diagnosis context).

    Returns:
        Tuple of (success: bool, encounter_id: str).
        encounter_id is empty string on failure.
    """
    async def _run() -> tuple[bool, str]:
        try:
            from openemr_client import OpenEMRClient, OpenEMRAPIError  # type: ignore[import]

            # Build SOAP note sections from the synced markers.
            diagnosis   = (patient_info.get("diagnoses") or ["Stage II breast cancer"])[0]
            today_str   = _date_cls.today().isoformat()

            # O â€” objective findings: one line per biomarker champion.
            objective_lines = " | ".join(
                f"{r.get('marker_name', '?')} {r.get('marker_value', '?').capitalize()}"
                for r in new_items
            )

            # Derive clinical assessment from the marker set.
            er_pos  = any("er" == r.get("marker_name","").lower() and "pos" in r.get("marker_value","").lower() for r in new_items)
            her2_neg = any("her2" == r.get("marker_name","").lower() and "neg" in r.get("marker_value","").lower() for r in new_items)
            receptor_profile = (
                "HR+/HER2âˆ’ profile" if (er_pos and her2_neg)
                else "receptor profile per biopsy"
            )

            subjective = (
                f"AgentForge RCM â€” Clinical Data Sync ({today_str}). "
                f"Patient: {patient_name}. "
                f"Diagnosis: {diagnosis}."
            )
            objective  = (
                f"Biopsy biomarkers extracted and deduplicated from PDF prior-auth submission: "
                f"{objective_lines}."
            )
            assessment = (
                f"Pathology confirms {receptor_profile}. "
                "Findings cross-referenced against payer policy criteria. "
                "Clinical documentation complete for prior authorization review."
            )
            plan = (
                "Biomarker data recorded in AgentForge audit trail (SYNCED). "
                "Duplicate extractions suppressed (SUPERSEDED). "
                "RCM team notified. No further documentation required for this encounter."
            )

            async with OpenEMRClient() as client:
                # Resolve a real FHIR UUID when patient_fhir_id is a short
                # mock ID (e.g. "P001" from mock_data/patients.json).
                # OpenEMR's encounter endpoint requires the actual patient UUID;
                # mock IDs cause a 404 or 422 from the API.
                _UUID_RE = re.compile(
                    r'^[0-9a-f]{8}-[0-9a-f]{4}-'
                    r'[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
                    re.IGNORECASE,
                )
                resolved_uuid = patient_fhir_id
                if not _UUID_RE.match(patient_fhir_id):
                    name_parts = patient_name.replace(".", "").split()
                    given  = name_parts[0] if name_parts else ""
                    family = name_parts[-1] if len(name_parts) > 1 else ""
                    try:
                        bundle  = await client.get_patients(family=family, given=given)
                        entries = (bundle or {}).get("entry", [])
                        if entries:
                            resolved_uuid = entries[0]["resource"]["id"]
                            logger.info(
                                "sync_execution_node: resolved real UUID %s "
                                "for patient '%s' (was '%s').",
                                resolved_uuid, patient_name, patient_fhir_id,
                            )
                        else:
                            logger.warning(
                                "sync_execution_node: no OpenEMR patient matched "
                                "'%s' â€” SOAP note skipped.",
                                patient_name,
                            )
                            return False, ""
                    except Exception as _resolve_exc:
                        logger.warning(
                            "sync_execution_node: UUID resolution failed for "
                            "'%s' â€” %s. SOAP note skipped.",
                            patient_name, _resolve_exc,
                        )
                        return False, ""

                # Step 1 â€” create an encounter to anchor the SOAP note.
                enc = await client.post_encounter(
                    patient_uuid=resolved_uuid,
                    reason=f"AgentForge RCM Biomarker Sync â€” {today_str}",
                )
                # OpenEMR's SOAP note endpoint uses the integer encounter id
                # (eid), NOT the UUID (euuid).  Using the UUID causes the form
                # to be created with pid=0, encounter=0 (orphaned / invisible
                # in the patient chart).
                enc_eid: str = str(enc.get("eid") or enc.get("encounter") or "")
                enc_euuid: str = enc.get("euuid") or enc.get("id") or ""

                if not enc_eid:
                    logger.warning(
                        "sync_execution_node: encounter created but no eid returned â€” %s", enc
                    )
                    return False, ""

                # Step 2 â€” post the SOAP note under that encounter using eid.
                await client.post_soap_note(
                    patient_uuid=resolved_uuid,
                    encounter_uuid=enc_eid,
                    subjective=subjective,
                    objective=objective,
                    assessment=assessment,
                    plan=plan,
                )
                logger.info(
                    "sync_execution_node: SOAP note posted to OpenEMR "
                    "(patient=%s encounter_eid=%s encounter_uuid=%s).",
                    resolved_uuid, enc_eid, enc_euuid,
                )

                # OpenEMR's SOAP note REST endpoint creates the form with
                # pid=0 in the `forms` table even when the encounter is
                # correctly linked.  Fix the linkage via a targeted SQL
                # update so the note appears in the patient's chart UI.
                _fix_soap_pid(enc_eid)

                return True, enc_euuid or enc_eid

        except Exception as exc:
            logger.warning(
                "sync_execution_node: SOAP note post failed â€” %s", exc
            )
            return False, ""

    # Run the async helper from this synchronous context.
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as pool:
                future = pool.submit(asyncio.run, _run())
                return future.result(timeout=30)
        else:
            return loop.run_until_complete(_run())
    except Exception as exc:
        logger.warning("sync_execution_node: SOAP note async wrapper failed â€” %s", exc)
        return False, ""
